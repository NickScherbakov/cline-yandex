# Примеры промптов для YandexGPT

Этот документ содержит примеры эффективных промптов для работы с YandexGPT через библиотеку `yandex-cloud-connector`. Правильно составленные промпты помогут получить наилучшие результаты от моделей.

## Основные принципы промптинга

### 1. Будьте конкретны

Чем конкретнее запрос, тем точнее будет ответ. Указывайте:
- Четкую задачу
- Желаемый формат ответа
- Контекст задачи

### 2. Используйте системный промпт

Системный промпт задает общее поведение модели на весь диалог. Используйте его для:
- Определения роли модели
- Установки ограничений
- Задания стиля ответов

### 3. Контролируйте формат ответа

Укажите желаемый формат ответа:
- Структурированные данные (JSON, таблица)
- Разделы с заголовками
- Списки или пронумерованные шаги

## Примеры промптов для разных задач

### Генерация кода

#### Системный промпт:

```
Ты - опытный разработчик с глубоким знанием различных языков программирования. 
Твоя задача - писать эффективный, хорошо структурированный и документированный код.
Всегда отвечай только кодом, не добавляя лишних пояснений до или после.
```

#### Пользовательский запрос:

```
Напиши функцию на TypeScript для преобразования глубоко вложенного объекта в плоскую структуру с ключами через точку. 
Функция должна работать рекурсивно и поддерживать массивы. 
Пример входных данных: 
{ 
  user: { 
    name: "John", 
    address: { 
      city: "Moscow", 
      street: "Lenina" 
    }, 
    hobbies: ["tennis", "chess"] 
  } 
}
Ожидаемый результат: 
{ 
  "user.name": "John", 
  "user.address.city": "Moscow", 
  "user.address.street": "Lenina", 
  "user.hobbies.0": "tennis", 
  "user.hobbies.1": "chess" 
}
```

### Анализ кода

#### Системный промпт:

```
Ты - эксперт по анализу кода и рефакторингу. Твоя задача - находить потенциальные проблемы, предлагать улучшения и объяснять, как работает код.
```

#### Пользовательский запрос:

```
Проанализируй следующую функцию и предложи улучшения с точки зрения производительности и читаемости:

function findDuplicates(array) {
  let duplicates = [];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0; j < array.length; j++) {
      if (i !== j && array[i] === array[j] && !duplicates.includes(array[i])) {
        duplicates.push(array[i]);
      }
    }
  }
  return duplicates;
}
```

### Генерация документации API

#### Системный промпт:

```
Ты - технический писатель, специализирующийся на документации API. Твоя задача - создавать четкую, понятную и исчерпывающую документацию.
```

#### Пользовательский запрос:

```
Создай документацию API для следующего метода сервиса аутентификации:

async function authenticateUser(email, password, options = { rememberMe: false, deviceId: null }) {
  const user = await UserRepository.findByEmail(email);
  if (!user) throw new AuthenticationError('User not found');
  
  const isValid = await bcrypt.compare(password, user.passwordHash);
  if (!isValid) throw new AuthenticationError('Invalid password');
  
  const token = jwt.sign({ 
    userId: user.id, 
    role: user.role,
    deviceId: options.deviceId
  }, process.env.JWT_SECRET, {
    expiresIn: options.rememberMe ? '30d' : '24h'
  });
  
  return { user, token };
}
```

### Оптимизация SQL-запросов

#### Системный промпт:

```
Ты - опытный специалист по базам данных. Твоя задача - оптимизировать SQL-запросы и объяснять предложенные изменения.
```

#### Пользовательский запрос:

```
Оптимизируй следующий SQL-запрос для большой базы данных:

SELECT u.name, u.email, COUNT(o.id) as orders_count 
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
WHERE u.registration_date > '2022-01-01' 
AND u.is_active = true 
GROUP BY u.name, u.email 
ORDER BY orders_count DESC;
```

### Создание юнит-тестов

#### Системный промпт:

```
Ты - специалист по тестированию программного обеспечения. Твоя задача - создавать эффективные и полные юнит-тесты для кода.
```

#### Пользовательский запрос:

```
Напиши юнит-тесты на Jest для следующей функции:

function validatePassword(password) {
  if (typeof password !== 'string') return false;
  if (password.length < 8) return false;
  if (!/[A-Z]/.test(password)) return false;
  if (!/[a-z]/.test(password)) return false;
  if (!/[0-9]/.test(password)) return false;
  if (!/[!@#$%^&*]/.test(password)) return false;
  return true;
}
```

## Специфика работы с русским языком

YandexGPT хорошо обучен на русскоязычных данных, что делает его особенно эффективным для задач, связанных с русским языком. Используйте эти преимущества в своих промптах.

### Анализ текста на русском языке

#### Системный промпт:

```
Ты - эксперт по русской филологии и лингвистике. Твоя задача - анализировать тексты на русском языке и предоставлять подробный разбор.
```

#### Пользовательский запрос:

```
Проведи лингвистический анализ следующего текста:

"В тени деревьев, шелестящих на легком весеннем ветру, сидел старик с потрепанной книгой в руках. Его морщинистое лицо выражало спокойствие и умиротворение, словно страницы этой книги содержали все ответы на вечные вопросы бытия."

Анализ должен включать:
1. Лексический разбор (используемые части речи, их роль)
2. Синтаксические особенности (структура предложений)
3. Стилистические приемы
4. Общее настроение и эмоциональная окраска текста
```

### Перевод с учетом культурных особенностей

#### Системный промпт:

```
Ты - профессиональный переводчик с глубоким знанием культурных особенностей России и англоязычных стран. Твоя задача - не просто переводить текст, но и адаптировать культурные референсы.
```

#### Пользовательский запрос:

```
Переведи следующий текст на английский язык, адаптируя культурные референсы для американской аудитории:

"На майские праздники мы с друзьями традиционно выезжаем на дачу. Жарим шашлыки, паримся в бане, а вечером устраиваем посиделки с гитарой и песнями Высоцкого. В этом году нас застал врасплох внезапный град размером с перепелиное яйцо!"
```

## Суммаризация текста

Для модели `summarization` промпты имеют свою специфику. Эта модель обучена на задаче суммаризации русскоязычных текстов и хорошо справляется с сжатием объемных материалов до их ключевых идей.

### Пример использования модели summarization:

```typescript
const connector = new YandexCloudConnector({
  apiKey: 'ваш-api-ключ',
  folderId: 'ваш-folder-id',
  modelId: 'summarization'
});

const longText = `
Длинная статья или документ, который нужно суммаризировать...
(много текста)
`;

// Использование специального метода для суммаризации
const summary = await connector.summarize(longText);
console.log(summary);
```

## Дополнительные советы

### Итеративное улучшение промптов

Иногда трудно получить идеальный результат с первого раза. Используйте итеративный подход:

1. Начните с базового промпта
2. Проанализируйте ответ
3. Скорректируйте промпт, делая его более конкретным
4. Повторите процесс до получения желаемого результата

### Использование температуры

Параметр `temperature` контролирует "креативность" модели:

- **Низкая температура** (0.1-0.3): Более предсказуемые, консервативные ответы. Лучше для фактических задач и код-генерации.
- **Средняя температура** (0.4-0.7): Баланс между креативностью и предсказуемостью.
- **Высокая температура** (0.8-1.0): Более разнообразные и творческие ответы. Лучше для креативных задач.

### Комбинирование подходов

Для сложных задач эффективно комбинировать различные техники промптинга:

```
Ты - опытный инженер-программист и технический писатель.

Задача: Изучи следующий код на Python, который реализует алгоритм сортировки слиянием.

1. Объясни, как работает этот алгоритм, шаг за шагом, на понятном русском языке.
2. Выяви потенциальные проблемы в реализации.
3. Предложи оптимизации для улучшения производительности.
4. Напиши юнит-тесты для проверки корректности работы алгоритма.

Код:
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    
    left = merge_sort(left)
    right = merge_sort(right)
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```